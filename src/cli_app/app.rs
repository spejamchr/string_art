use crate::clap::app_from_crate;
use crate::clap::App;
use crate::clap::Arg;
use crate::imagery::Rgb;
use crate::util;

fn valid_type<T: std::str::FromStr>(name: &str) -> impl Fn(String) -> Result<(), String> {
    let name = name.to_owned();
    move |f| {
        f.parse::<T>()
            .map(|_| ())
            .map_err(|_| format!("Expected {} but got \"{}\"", name, f))
    }
}

fn float_in_range(min: f64, max: f64) -> impl Fn(String) -> Result<(), String> {
    move |f| {
        f.parse::<f64>()
            .ok()
            .and_then(|f| util::from_bool(f > min && f <= max)(f))
            .map(|_| ())
            .ok_or_else(|| {
                format!(
                    "Expected Float on range {} < Float <= {} but got \"{}\"",
                    min, max, f
                )
            })
    }
}

pub fn create() -> App<'static, 'static> {
    app_from_crate!()
    .arg(Arg::with_name("input_filepath")
        .value_name("FILEPATH")
        .short("i")
        .long("input-filepath")
        .takes_value(true)
        .required(true)
        .help("Path to the image that will be rendered with strings.")
    )
    .arg(Arg::with_name("output_filepath")
        .value_name("FILEPATH")
        .short("o")
        .long("output-filepath")
        .takes_value(true)
        .help("Location to save generated string image.")
    )
    .arg(Arg::with_name("pins_filepath")
        .value_name("FILEPATH")
        .short("p")
        .long("pins-filepath")
        .takes_value(true)
        .help("Location to save image of pin locations.")
    )
    .arg(Arg::with_name("data_filepath")
        .value_name("FILEPATH")
        .short("d")
        .long("data-filepath")
        .takes_value(true)
        .help("The script will write operation information as a JSON file if this filepath is given. The operation information includes argument values, starting and ending image scores, pin locations, and a list of line segments between pins that form the final image.")
    )
    .arg(Arg::with_name("gif_filepath")
        .value_name("FILEPATH")
        .short("g")
        .long("gif-filepath")
        .takes_value(true)
        .help("Location to save a gif of the creation process")
    )
    .arg(Arg::with_name("max_strings")
        .value_name("INTEGER")
        .short("m")
        .long("max-strings")
        .takes_value(true)
        .validator(valid_type::<usize>("Integer"))
        .help("The maximum number of strings in the finished work.")
    )
    .arg(Arg::with_name("step_size")
        .value_name("FLOAT")
        .short("s")
        .long("step-size")
        .takes_value(true)
        .default_value("1.0")
        .validator(float_in_range(0.0, 50.0))
        .help("Used when calculating a string's antialiasing. Smaller values -> finer antialiasing. [range: 0 < value <= 50]")
    )
    .arg(Arg::with_name("string_alpha")
        .value_name("FLOAT")
        .short("a")
        .long("string-alpha")
        .takes_value(true)
        .default_value("0.2")
        .validator(float_in_range(0.0, 1.0))
        .help("How opaque or thin each string is. `1` is entirely opaque, `0` is invisible. [range: 0 < value <= 1]")
    )
    .arg(Arg::with_name("pin_count")
        .value_name("INTEGER")
        .short("c")
        .long("pin-count")
        .takes_value(true)
        .default_value("200")
        .validator(valid_type::<u32>("Integer"))
        .help("How many pins should be used in creating the image (approximately).")
    )
    .arg(Arg::with_name("pin_arrangement")
        .value_name("ARRANGEMENT")
        .short("r")
        .long("pin-arrangement")
        .takes_value(true)
        .possible_values(&["perimeter", "grid", "circle", "random"])
        .default_value("perimeter")
        .help("Should the pins be arranged on the image's perimeter, or in a grid across the entire image, or in the largest possible centered circle, or scattered randomly?")
    )
    .arg(Arg::with_name("background_color")
        .value_name("HEX CODE")
        .short("b")
        .long("background-color")
        .takes_value(true)
        .default_value("#000000")
        .validator(valid_type::<Rgb>("Hex Code"))
        .help("An RGB color in hex format `#RRGGBB` specifying the color of the background.")
    )
    .arg(Arg::with_name("foreground_color")
        .value_name("HEX CODE")
        .short("f")
        .long("foreground-color")
        .takes_value(true)
        .multiple(true)
        .default_value("#FFFFFF")
        .validator(valid_type::<Rgb>("Hex Code"))
        .help("An RGB color in hex format `#RRGGBB` specifying the color of a string to use. Can be specified multiple times to specify multiple colors of strings.")
    )
    .arg(Arg::with_name("auto_color")
        .value_name("INTEGER")
        .short("u")
        .long("auto-color")
        .takes_value(true)
        .validator(valid_type::<u32>("Integer"))
        .help("Draw with this many automatically chosen foreground colors on an automatically chosen background color.

If --background-color is provided, use that.

If --foreground-color is provided, use that in addition to this many additional automatically chosen foreground colors.")
    )
    .arg(Arg::with_name("verbose")
        .short("v")
        .long("verbose")
        .multiple(true)
        .help("Output debugging messages. Pass multiple times for more verbose logging.")
    )
}
